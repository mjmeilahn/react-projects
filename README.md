# React Projects

1. Basics - Exploring basic functional Components. Importing components, passing props, dynamic classNames. No look at state management yet, purely static components.

2. Reactive State Management - Local Component State Communication from Child to Parent. Two-Way Binding. Difference between individual vs. multiple set-state functions, conditional filtering of arrays and components. Basic intro to Hooks with "useState()" that returns an array of the value of its state and set state function.

3. Styling - In depth look at Global CSS, Styled Components and CSS Modules. Exploring Pros & Cons of each and how reactive JS utilizes these approaches.

4. Fragments, Portals, Refs - Rendering Sibling components with React.Fragment, Fragment or <></> as its shorthand. Passing components to any DOM node via Portals and ReactDOM library - useful for components like Modals that need to be decoupled from a HTML hierarchy. Using Refs to pass input values without listening to every keystroke - there are performance improvements to this method even if the elements become an uncontrolled component - because React is no longer managing that individual element, it is handled natively from the browser.

5. Effects - useEffect() is a lifecycle hook that listens to changes (whether you specify dependencies - state by itself inside useEffect does not need to be its own dependency) and reacts to them however you specify to handle unique edge cases in your application. Best for single changes, not continuous changes like keystrokes into a text input element. For continuous changes, think of how you can utilize a debounce effect that fires after a pause in user interaction OR use the onBlur event - and then run useEffect() or an event handler like a function. Never call useEffect() outside of a React component or within a nested function or conditional statement.

6. Reducers, Context API - useReducer() is a lifecycle hook that expands on useState() for state management kind of like a mini-Redux that dispatches actions with a payload and updates state. Useful for state that requires a hierarchy but useState() is the standard approach. Context API allows component communication with "global" state to any component regardless of Parent-Child status. In some cases it can be a simple alternative to state management than Redux callable through useContext() hook. However, Context can quickly become unsustainable for high performance state updates, overly nested in JSX or have a massive architecture that is difficult to reason about or debug. These are the clear cases to avoid Context API and choose Redux for state management. As before with useEffect(), never call useReducer() or useContext() outside of a React component or within a nested function or conditional statement.

7. Parent-Child Seletive Re-render Techniques - Learning how to optimize large apps with hooks React.memo(), useCallback() & useMemo(). Usually this technique is sought in response to large applications that need to increase their performance - which is a good problem to have. Essentially when a Parent component's state updates it will re-render its child components. Exploring these lifecycle hooks to selectively render child components, store functions or data internally.

8. Class Components - Exploring class lifecycle methods, translating Functional compoents to Classes and how to manage state in class components. Since React 16.8 functional hooks like useState(), useEffect(), useContext() and useReducer() have been the suggested way to build React applications - however, class components are still highly used in the React ecosystem and knowledge of how to use these are highly suggested.

9. HTTP & Asynchronous Requests - Basic example of showing content or handling edge cases in asynchronous behavior with functional hook useCallback() in React applications. Using free Star Wars API & fetch() browser method as an example.

10. Custom Hooks - Abstracting React hooks like "useState" and "useEffect" into a composable, reusable function. A custom hook is the only place to put these hooks as they cannot be stored in regular functions or conditional statements. Every custom hook must begin with the keyword "use" to be recognized by React.

11. Form Validation - Exploring various approaches to validating forms via Refs and State. Looking mainly at Blur events in the DOM to provide real-time feedback to users on a particular input element with a custom message.

12. Plain Redux, Class-component Redux, Toolkit Redux (NPM) and React-Redux (NPM) - Adds Redux to a simple state management application in various flavors of Redux. This library should be utilized in an immutable fashion where predictable input generates predictable output with no side effects (aka Pure Functions). To update state, Redux follows this pattern: Any Function -> Dispatch -> Action Type -> Reducer Function -> Return New State -> Subscribe To Changes -> Update UI. Preferred approach in my personal opinion is a combination between Redux Toolkit and React-Redux (no Class Redux!). Best example which incorporates this combination is /components/Counter.js and /store/index.js. Toolkit has libraries built-in which handle immutability so state can be updated on simple one-liners depending on the payload.

13. Async Redux - Common patterns how to handle state updates that rely on asynchronous requests. In short there are two main options in React: a) Make an AJAX request inside "useEffect()" OR b) Host the AJAX request as an Action Creator "thunk" in the respective slice file (React Toolkit) that updates its state.

14. React Router - Common routing patterns in React. Nested routes, logic in routes and main differences in React Router 5 vs. React Router 6.

15. Basic NextJS - Simple routing example where Next has a file+folder approach instead of the custom approach via React Router. In all Next apps the first page fetched by a user is the rendered DOM from a server, and future requests are made through a React application. DOM elements need to be in their hard coded state OR pre-fetched through an API in the build process or on each server request as Next will not pre-render elements that require State Management or Hooks to update their appearance by default e.g. useState(), useEffect(), useReducer() or useContext() - otherwise this fact can defeat the purpose of using Next if static or server-side rendering for SEO was the main goal. In addition the default behavior for every Next app is to automatically code split each page, lazy load components and Image components are also lazily loaded.

16. Advanced NextJS - In depth example of Static vs. Server Side Rendering for a respective page, areas to host Back End requests and responses via "/api" folder, how to render dynamic pages via Static Paths, Meta and Title tags for each page. Important to note that Static or Server rendered content that updates via a Headless CMS like Contentful are not immediately shown except by manually re-deploying each time or one of two cases. First, for non-dynamic (purely static) pages one user from traffic needs to land on the respective page - whilst Next fetches the data the initial time it will re-check its Static/Server props and have the updated Static/Server rendered page ready for each additional view depending on the "revalidate" value. Second, a dynamic page will need a dedicated fallback page to fetch Static/Server props when it re-checks for updates and then it will create a new Static/Server rendered page in the background, where each additional view can then see updates.

17. React NodeGUI - Basic example of using React for native desktop applications which compile down to Qt pre-compiled C++ components. The exports are performant for any OS including Mac, Windows or Linux. Important to note React NodeGUI library does not have full support or developers to maintain it unlike alternatives such as Electron.

18. Next + Contentful Headless CMS - Diving into how to fetch different data fields from Contentful CMS. Essentially all you would need is an API key and a way to gracefully update new content created from inside Contentful. There are several options to host and deploy Next where changes can be subscribed via a Webhook & Deploy Hook. For incremental changes, Next can handle this through its Static/Server Props methods. However if you have sensitive content that must be visible on each change a subscribed webhook that deploys each push to production would be recommended.

19. ARCHIVED. FishInventory - REACT + FIREBASE - This app uses authentication to log into your real-time Firebase data using a GitHub account, in order to persist unique data. Application state is updated on a parent component, passes unidirectional data flow into its child components. You can adjust inventory in your shop - Firebase passes real-time data to the store and prevents customers from having SOLD OUT items in their cart. There is no Checkout or Payment steps included in this demonstration.

20. ARCHIVED. React 16 Basics - Exploring basic Class vs. Functional Components. Importing components, passing JS, dynamic classNames, Props & State, Styled Components, Error Boundaries, Two-Way-Binding in JSX. Basic intro to Hooks with "useState" and how Class components can become Functional with Hooks. First look at updating Immutable State.

21. ARCHIVED. Reduxstagram - REACT + REDUX - This app requires local storage and cookies to be enabled to persist unique data. State is managed through Redux, and follows Immutable data best practices. The instagram feed is some of my colorful graphic designs from 2011.